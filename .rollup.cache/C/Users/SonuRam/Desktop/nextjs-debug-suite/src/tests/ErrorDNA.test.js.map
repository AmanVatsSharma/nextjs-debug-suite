{"version":3,"file":"ErrorDNA.test.js","sourceRoot":"","sources":["ErrorDNA.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { ErrorDNAGenerator } from '../core/errorDNA/errorDNA';\r\nimport { StackTraceParser } from '../core/errorDNA/stackTraceParser';\r\nimport { DependencyAnalyzer } from '../core/errorDNA/dependencyAnalyzer';\r\n\r\ndescribe('ErrorDNAGenerator', () => {\r\n  let errorDNA: ErrorDNAGenerator;\r\n  let mockStackTraceParser: jest.Mocked<StackTraceParser>;\r\n  let mockDependencyAnalyzer: jest.Mocked<DependencyAnalyzer>;\r\n\r\n  beforeEach(() => {\r\n    mockStackTraceParser = {\r\n      parse: jest.fn(),\r\n    } as any;\r\n\r\n    mockDependencyAnalyzer = {\r\n      analyzeDependencies: jest.fn(),\r\n    } as any;\r\n\r\n    errorDNA = new ErrorDNAGenerator();\r\n  });\r\n\r\n  describe('generateDNA', () => {\r\n    it('analyzes error and returns DNA information', async () => {\r\n      const error = new Error('Test error');\r\n      const mockStackTrace = {\r\n        frames: [{\r\n          file: 'src/components/Button.tsx',\r\n          lineNumber: 42,\r\n          column: 5,\r\n          methodName: 'onClick',\r\n          context: 'export class Button',\r\n        }],\r\n        sourceCode: {\r\n          'src/components/Button.tsx': ['line1', 'line2', 'line3'],\r\n        },\r\n      };\r\n\r\n      mockStackTraceParser.parse.mockResolvedValue(mockStackTrace);\r\n      mockDependencyAnalyzer.analyzeDependencies.mockResolvedValue({\r\n        nodes: [],\r\n        edges: [],\r\n      });\r\n\r\n      const dna = await errorDNA.generateDNA(error);\r\n\r\n      expect(dna).toEqual(expect.objectContaining({\r\n        type: 'runtime',\r\n        location: expect.objectContaining({\r\n          file: 'src/components/Button.tsx',\r\n          line: 42,\r\n          column: 5,\r\n          functionName: 'onClick',\r\n          component: 'Button',\r\n        }),\r\n        visual: expect.objectContaining({\r\n          codePreview: expect.any(String),\r\n          highlightedLines: expect.arrayContaining([42]),\r\n          dependencies: expect.objectContaining({\r\n            nodes: [],\r\n            edges: [],\r\n          }),\r\n          stackTrace: expect.objectContaining({\r\n            frames: expect.arrayContaining([\r\n              expect.objectContaining({\r\n                file: 'src/components/Button.tsx',\r\n                line: 42,\r\n                column: 5,\r\n                function: 'onClick',\r\n              }),\r\n            ]),\r\n          }),\r\n        }),\r\n      }));\r\n    });\r\n\r\n    it('identifies error type based on stack trace', async () => {\r\n      const error = new TypeError('Invalid type');\r\n      const mockStackTrace = {\r\n        frames: [{\r\n          file: 'src/utils/validation.ts',\r\n          lineNumber: 15,\r\n          column: 3,\r\n          methodName: 'validateInput',\r\n        }],\r\n      };\r\n\r\n      mockStackTraceParser.parse.mockResolvedValue(mockStackTrace);\r\n      mockDependencyAnalyzer.analyzeDependencies.mockResolvedValue({\r\n        nodes: [],\r\n        edges: [],\r\n      });\r\n\r\n      const dna = await errorDNA.generateDNA(error);\r\n      expect(dna.type).toBe('type');\r\n    });\r\n\r\n    it('handles missing stack trace gracefully', async () => {\r\n      const error = new Error('No stack trace');\r\n      mockStackTraceParser.parse.mockResolvedValue({\r\n        frames: [],\r\n      });\r\n      mockDependencyAnalyzer.analyzeDependencies.mockResolvedValue({\r\n        nodes: [],\r\n        edges: [],\r\n      });\r\n\r\n      const dna = await errorDNA.generateDNA(error);\r\n      expect(dna).toEqual(expect.objectContaining({\r\n        location: expect.objectContaining({\r\n          file: 'unknown',\r\n          line: 0,\r\n          column: 0,\r\n          functionName: 'unknown',\r\n        }),\r\n      }));\r\n    });\r\n\r\n    it('handles parser errors gracefully', async () => {\r\n      const error = new Error('Parser error');\r\n      mockStackTraceParser.parse.mockRejectedValue(new Error('Parse failed'));\r\n      mockDependencyAnalyzer.analyzeDependencies.mockResolvedValue({\r\n        nodes: [],\r\n        edges: [],\r\n      });\r\n\r\n      await expect(errorDNA.generateDNA(error)).rejects.toThrow('Parse failed');\r\n    });\r\n  });\r\n}); "]}